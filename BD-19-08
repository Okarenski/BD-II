CREATE TABLE Funcionario (
	ID serial primary key,
	nome text, 
	salario numeric (10,2)
);

CREATE TABLE Funcionario_log (
	ID serial primary key,
	id_funcionario int, 
	novo_salario numeric (10,2), 
	data_alteracao TIMESTAMPTZ NOT NULL DEFAULT now()
); -- timestamptz inclui fuso horário

CREATE TABLE Email_func (
	nome text,
	funcionario_id INT NOT NULL,
	CONSTRAINT fk_funcionario
        FOREIGN KEY (funcionario_id) 
        REFERENCES Funcionario(id)
)

insert into Funcionario (nome, salario)
values ('Saldanha', 1000)
	  ,	('maria', 100000)
	  , ('joao', 5000)
	  
insert into Funcionario (nome, salario)
values ('jesus', 1000)

/*insert into Email_func (email, funcionario_id)
values ('algumacoisa@gmail.com', 1),
	   ('sla@gmail.com', 2),
	   ('nha@gmail.com', 3),
	   ('opa@gmail.com', 4);
*/

SELECT * FROM Funcionario;
SELECT * FROM Funcionario_log;
SELECT * FROM Email_func;


DROP FUNCTION IF EXISTS f_log_func();

CREATE OR REPLACE FUNCTION f_log_func() 
RETURNS TRIGGER AS $$ 
BEGIN 
  INSERT INTO Funcionario_log (id_funcionario, novo_salario, data_alteracao, antigo_salario) 
  VALUES (NEW.id, NEW.salario, now(), OLD.salario); 
  IF NEW.salario > OLD.salario * 2 THEN
  RAISE EXCEPTION 'Funcionario não pode receber mais que o dobro de salario';
  END IF;
 RETURN OLD; 

END; 
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION e_func()
RETURNS TRIGGER AS $$
BEGIN
	INSERT INTO Email_func (nome, funcionario_id)
	VALUES (NEW.nome, NEW.id);
	RAISE NOTICE 'Novo funcionario foi adicionado';
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION d_funcfunc()
RETURNS TRIGGER AS $$
BEGIN
	RAISE EXCEPTION 'Funcionario não pode ser deletado pois teve mudanca de salario';
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;
	

CREATE TRIGGER e_newfunc
AFTER INSERT
ON Funcionario
FOR EACH ROW
EXECUTE FUNCTION e_func();

CREATE TRIGGER g_logfunc
AFTER UPDATE
ON Funcionario
FOR EACH ROW
WHEN (old.salario<>new.salario)
EXECUTE FUNCTION f_log_func();

CREATE TRIGGER d_func
BEFORE DELETE
ON Funcionario
FOR EACH ROW
WHEN (!funcionario_log.antigo_salario==new.salario)
EXECUTE FUNCTION d_funcfunc();

alter table funcionario_log add column antigo_salario numeric



update Funcionario set salario = 12000 where id = 2;
update Funcionario set salario = 30000 where id = 4;
update funcionario set salario = 5000 where id = 1;

select fl.id, f.nome, fl.novo_salario, fl.data_alteracao
	from Funcionario_log fl
inner join funcionario f on (f.id = fl.id_funcionario)

--aula 26/08

CREATE OR REPLACE FUNCTION minha_trigger_func()
RETURNS TRIGGER AS $$
BEGIN
  RAISE NOTICE 'Operação: %', TG_OP;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_tg_op
AFTER INSERT OR UPDATE OR DELETE
ON funcionario
FOR EACH ROW
EXECUTE FUNCTION minha_trigger_func();


CREATE OR REPLACE FUNCTION minha_trigger_func()
RETURNS TRIGGER AS $$
BEGIN
  CASE TG_OP
    WHEN 'INSERT' THEN
      RAISE NOTICE 'Operação: INSERT';
      -- só NEW disponível
      RETURN NEW;

    WHEN 'UPDATE' THEN
      RAISE NOTICE 'Operação: UPDATE';
      -- OLD e NEW disponíveis
      RETURN NEW;

    WHEN 'DELETE' THEN
      RAISE NOTICE 'Operação: DELETE';
      -- só OLD disponível
      RETURN OLD;
  END CASE;

  RETURN NULL; -- fallback (boa prática)
END;
$$ LANGUAGE plpgsql;


Quando for inserido um funcionario, sempre deixe o nome em maisculo
Somente excluir funcionarios que que nao tenham log de alteracao 
Nao aumentr o salario para mais de 50% do valor




CREATE OR REPLACE FUNCTION public.insert_func_null_salario()
RETURNS TRIGGER AS $$
BEGIN
	RAISE NOTICE 'insert_func_null_salario % %', NEW.salario, NEW.nome;
	RAISE NOTICE 'insert_func_null_salario % %', old.salario, old.nome;
	IF (new.salario = 0) THEN
		RAISE EXCEPTION 'Impossível cadastrar funcionário sem salário';
	END IF;
	RETURN new;
END; $$ LANGUAGE plpgsql; 


CREATE OR REPLACE TRIGGER g_exception_null_salario
BEFORE INSERT OR UPDATE
ON public.Funcionario
EXECUTE FUNCTION public.insert_func_null_salario();

UPDATE Funcionario SET salario = 20 WHERE id = 1;
SELECT * FROM Funcionario;








-- Table: public.func_email

-- DROP TABLE IF EXISTS public.func_email;

CREATE TABLE IF NOT EXISTS public.func_email
(
    id integer NOT NULL DEFAULT nextval('func_email_id_seq'::regclass),
    id_func integer NOT NULL,
    nome_func text COLLATE pg_catalog."default",
    data_inclusao date,
    enviado boolean,
    CONSTRAINT func_email_pkey PRIMARY KEY (id),
    CONSTRAINT func_email_id_func_fkey FOREIGN KEY (id_func)
        REFERENCES public.funcionario (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.func_email
    OWNER to postgres;



create table produto (
  id_produto serial primary key,
  nome text,
  preco numeric (10,2),
  estoque int,	
  tipo_prod int	
);

insert into produto(nome, preco, estoque, tipo_prod)
values 
('sofa', 123.10, 20, 1),
('cama', 145.16, 25, 2),
('beliche', 173.18, 10, 1),
('mesa', 121.10, 20, 2),
('cadeira', 12.10, 27, 3),
('estante', 173.90, 23, 1),
('pia', 23.01, 22, 2);


CREATE TABLE IF NOT EXISTS log_auditoria (
  id_log serial PRIMARY KEY,
  tabela_afetada text NOT NULL,
  id_registro_afetado integer,
  operacao text NOT NULL,
  detalhes text,
  data_alteracao timestamptz NOT NULL DEFAULT now()
);

select * from log_auditoria

CREATE OR REPLACE PROCEDURE ajustar_preco_por_tipo(
    IN p_tipo_prod integer,
    IN p_percent numeric
)
LANGUAGE plpgsql
AS $$
DECLARE
    rec RECORD;
    v_preco_novo numeric(10,2);
BEGIN
    FOR rec IN
        SELECT id_produto, nome, preco, estoque
        FROM produto
        WHERE tipo_prod = p_tipo_prod
    LOOP
        v_preco_novo := ROUND(rec.preco * (1 + p_percent/100.0), 2);

        UPDATE produto
        SET preco = v_preco_novo
        WHERE id_produto = rec.id_produto;

        RAISE NOTICE 'Produto: % | Estoque: % | Preco antigo: %.2f -> Novo preco: %.2f | Data: %',
            rec.nome, rec.estoque, rec.preco, v_preco_novo, now();
    END LOOP;
END;
$$;













SELECT id_produto, nome, tipo_prod, preco FROM produto ORDER BY id_produto;

CALL ajustar_preco_por_tipo(1, -10);
CALL ajustar_preco_por_tipo(2, 20);


CALL ajustar_preco_por_tipo(1, -10);






CALL ajustar_preco_por_tipo(2, 20);


SELECT id_produto, nome, tipo_prod, preco FROM produto ORDER BY id_produto;

SELECT id_log, tabela_afetada, id_registro_afetado, operacao, detalhes, data_alteracao
FROM log_auditoria
WHERE tabela_afetada = 'produto'
ORDER BY data_alteracao DESC;

rollback --VOLTA ATUALIZACAO
begin --ABRE TRANSACAO
commit --ATUALIZA ELA NO BANCO

select * from account, funcionario
select * from funcionario

update funcionario set salario = 5000 where id = 1

alter table funcionario
add historico varchar(50)

alter table account 
add historico varchar(50)

update account
set balance = (select salario from funcionario where id = 1)
WHERE id = 1

update funcionario set salario = salario - salario where id = 1













